---
name: optimize
description: 执行完整的性能优化流程，自动分析并优化代码性能
---

# 性能优化任务

请按照以下步骤执行完整的性能优化流程：

## 1. 性能分析

首先，使用 `performance-expert` 的方法论分析项目性能：

### 后端分析
- 检查 `src/Host.Api/Endpoints/` 下所有端点的响应时间
- 识别可能的 N+1 查询
- 检查是否有同步阻塞调用（.Result, .Wait()）
- 检查是否正确使用 CancellationToken

### 前端分析
- 检查 `intellimaint-ui/src/pages/` 下的组件渲染性能
- 识别不必要的重渲染
- 检查大列表是否使用虚拟化
- 检查是否合理使用 memo/useMemo/useCallback

### 数据库分析
- 检查 `src/Infrastructure/Sqlite/` 下的查询效率
- 确认关键查询有索引
- 检查批量操作是否使用事务

## 2. 优化实施

根据分析结果，按优先级执行优化：

### 高优先级（必须）
1. 修复所有同步阻塞调用
2. 修复 N+1 查询
3. 添加缺失的索引

### 中优先级（建议）
1. 添加适当的缓存
2. 优化前端渲染
3. 实现批量操作

### 低优先级（可选）
1. 代码结构优化
2. 资源压缩

## 3. 验证测试

优化完成后：

1. 运行现有测试确保无回归
```bash
dotnet test
```

2. 如有必要，添加性能测试

## 4. 生成报告

生成优化报告，包含：
- 发现的问题列表
- 实施的优化措施
- 优化前后对比（如可测量）
- 剩余建议

---

**注意事项**：
- 每次修改前确保理解现有代码逻辑
- 保持代码风格一致
- 重大变更需要先评估影响范围
- 优先保证正确性，其次才是性能

## ⚠️ 质量门禁 (必须满足)

性能优化必须基于数据，完成以下所有步骤才能视为完成：

### 基线测量 (度量驱动)
- [ ] **记录基线** - 优化前的性能指标 (响应时间/内存/CPU)
- [ ] **测量方法** - 说明使用什么工具测量
- [ ] **目标设定** - 明确优化目标是多少

### 瓶颈识别
- [ ] **量化问题** - 用数字说明问题严重程度
- [ ] **代码定位** - 提供 `文件:行号` 指出瓶颈位置
- [ ] **根因分析** - 解释为什么这里是瓶颈

### 优化验证
- [ ] **重新测量** - 优化后使用相同方法测量
- [ ] **对比数据** - 提供优化前后对比表
- [ ] **无回归** - `dotnet test` 全部通过

### ❌ 不合格示例
```markdown
优化完成:
- 添加了缓存           ← 没有说明优化前性能
- 性能应该提升了       ← 没有测量数据
```

### ✅ 合格示例
```markdown
## 性能优化报告

### 基线数据
| 指标 | 优化前 | 测量方法 |
|------|--------|----------|
| API P95 | 250ms | 日志分析 1000 次请求 |
| 批量插入 1000条 | 1200ms | BenchmarkDotNet |

### 瓶颈识别
**文件**: `src/Infrastructure/Sqlite/DbExecutor.cs:180`
- 问题: 循环单条 INSERT，每条约 1.2ms
- 影响: 1000 条需要 1200ms

### 优化实施
**文件**: `src/Infrastructure/Sqlite/DbExecutor.cs:180`
- 方案: 多值 INSERT 批量写入

### 优化结果
| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 批量插入 1000条 | 1200ms | 80ms | 93% |

### 验证
- [x] 测试通过 (48/48)
- [x] 功能无回归
```
